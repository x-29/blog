---
title: "深入理解计算机系统(csapp)笔记"
description: "深入理解计算机系统(Computer Systems A Programmer's Perspective 3rd)学习笔记."
date: 2022-05-15T20:32:12+08:00
draft: false
math: true
categories:
  - 读书笔记
tags:
  - cs
---
现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit），形成了数字革命的基础。

三种最重要的数字表示：
- 无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。
- 补码（two's-complement）编码表示有符号整数，有符号整数是可以为正或者为负的数字。
- 浮点数（floating-point）编码是表示实数。

计算机的这些表示法是用有限数量的位来对一个数字编码，当结果太大以至于不能表示时，某些运算就会溢出（overflow）。

### 信息存储

大多数计算机使用 8 位的*块*，或者*字节*（byte），作为最小的可寻址的内存单元，而不是访问内存中单独的位。

机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存**（virtual memory）。内存的每个字节（byte）都由一个唯一的数字来标识，称为它的**地址**（address），所有可能地址的集合就称为**虚拟地址空间**（virtual address space）。

虚拟地址空间只是一个展现给机器级程序的概念性映射。实际的实现时将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

编译器和运行时系统会将存储器空间划分为更可管理的单元，来存放不同的程序对象（program object)，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序的不同部分的存储。这种管理完全是在虚拟地址空间里完成的。

> C 语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的**第一个字节的虚拟地址**。

C 编译器把每个指针和类型信息联系起来，根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C 编译器维护着类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。

每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

> 指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型（比如整数或者浮点数）。

---

十六进制表示法
  - 一个字节由 8 个位组成。
    - 在二进制表示法中，它的值域是 $00000000_2$ ~ $11111111_2$。
    - 用十进制表示，它的值域是 $0_{10}$ ~ $255_{10}$
    - 二进制和十进制表示法对于描述位模式来说都不非常方便。二进制表示法太冗长，十进制表示与位模式的互相转化很麻烦。代替的方法是用十六进制表示。
  - 用十六进制数来表示位模式。
    - 使用数字 ‘0’～‘9’ 以及字符 ‘A‘～‘F’ 来表示 16 个可能的值，即 0 ~ 15。
    - 一个字节的值域为 $00_{16}$~$FF_{16}$

> 在 C 语言中，以 0x 或 0X 开头的数字常量被认为是十六进制的值。字符 'A' ~ 'F' 既可以是大写，也可以是小写。

---

每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。虚拟地址就是以一个字来编码的，所以字长决定了虚拟地址空间的最大大小。也就是说，对于一个字长为 $w$ 位的机器而言，虚拟地址的范围为 $0$ ~ $2^w-1$，程序最多可访问 $2^w$ 个字节。
- 32 位字长的机器，虚拟地址空间为 4 千兆字节（4GB，$2^{32}$，字节是最小的可寻址的内存单元，每个字节都有一个虚拟地址），也就是说，刚刚超过 $4$ x $10^9$ 字节。
- 64 位字长的机器，虚拟地址空间为 16EB（$2^{64}$)，大约是 $1.84$ x $10^9$ 字节。

> C 语言，声名指针:
>
> 对于任何数据类型 T，声明
>
> T *p;
>
> 表明 p 是一个指针变量，指向一个类型为 T 的对象。例如，
>
> char *p;
>
> 就是将一个指针声明为指向一个 char 类型的对象。


指针变量，在 32 位程序中为 4 个字节，在 64 位程序中为 8 个字节。

---

对于跨越多个字节的程序对象，需要考虑两个问题：
- 这个对象的地址是什么？
- 在内存中如何排列这些字节（位如何排列）？

在几所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

例如，一个类型为 int 的变量 x 的地址为 0x100，也就是说，地址表达式 &x 的值为 0x100。那么，x 的 4 个字节将被存储在内存的 `0x100`、`0x101`、`0x102` 和 `0x103` 位置。

字节如何排列呢？ 考虑一个 $w$ 位的整数，其位表示为 [$x_{w-1}, x_{w-2}, ..., x_1, x_0$]，其中 $x_{w-1}$ 是最高有效位，而 $x_0$ 是最低有效位。假设 $w$ 是 8 的倍数，这些位就能被分组成为字节，其中最高有效字节包含位 [$x_{w-1}, x_{w-2}, ..., x_{w-8}$]，而最低有效字节包含位 [$x_7, x_6, ..., x_0$]，其他字节包含中间的位。

排列「表示一个对象的字节」有两个通用的方式：
- 小端法（little endian），在内存中按照从最低有效字节到最高有效字节的顺序存储对象。
- 大端法（big endian），按照从最高有效字节到最低有效字节的顺序存储对象，

{{<figure width="600" src="/images/big-little-endian.jpg">}}

假设变量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567，最高位字节的十六进制值为 0x01，最低字节值为 0x67。地址范围 0x100 ~ 0x1003 的字节顺序如上图。

---

C 语言中字符串被编码为一个以 null（其值为 0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是 ASCII 字符码。

在使用 ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。

---

C 语言中的位级运算：
- ｜（或）
- &（与）
- ～（取反）
- ^（异或）

这些运算能运用到任何“整型”的数据类型上。位级运算的一个常见用法是实现「掩码」运算，这里掩码是一个位模式，表示从一个「字」中选出的「位」的集合。
- 掩码 0xFF 表示一个字的低位字节，位级运算 x&0xFF生成一个由 x 的最低有效字节组成的值，而其他的字节就被置为 0。例如，x = 0x89ABCDEF，表达式 x&0xFF 将得到 0x000000EF。
- 表达式 ~0 将生成一个全 1 的掩码，不管机器的字大小是多少。


C 语言中的逻辑运算符：
- ||（或）
- &&（与）
- ！（非）

逻辑运算认为非零的数都表示真，0 表示假。它们返回 1 或者 0，分别表示结果为真或者为假。

例如，!0x41 = 0x00；!0x00 = 0x01。

---

C 语言中的移位运算：
- \>>（向左移位）
- \<<（向右移位）

对于一个位表示为 [$x_{w-1}, x_{w-2}, ..., x_0$] 的操作数 x，C 表达式 `x << k`，表示 x 向左移动 k 位，丢弃最高的 k 位，并在右端补 k 个 0，其位表示为 [$x_{w-k-1}, x_{w-k-2}, ..., x_0, 0, ..., 0$]。

右移运算 `x >> k`，有两种形式：
- 逻辑右移。在左端补 k 个 0，得到的结果是 [$0, ..., 0, x_{w-1}, x_{w-2}, ..., x_k$]。
- 算术右移。在左端补 k 个最高有效位的值，得到的结果是 [$x_{w-1}, ..., x_{w-1}, x_{w-1}, x_{w-2}, ..., x_k$]。

例如，x 的值为 $01100011_2$，$10010101_2$

x \<< 4  => [0011*0000*]，[0101*0000*]

x \>> 4（逻辑右移）=> [*0000**0110]，[*0000*1001]

x \>\> 4（算术右移）=> [*0000*0110]，[*1111*1001]

C 语言标准没有明确定义对于有符号数应该使用哪种类型的右移。然而，实际上几乎所有的编译器/机器组合都对符号数使用算术右移。对于无符号数，右移必须是逻辑右移。

### 整数表示

> C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数。

无符号数编码的定义：对于向量 $\vec{x}=[x_{w-1}, x_{w-2}, \cdots, x_0]$，定义函数：

$$B2U_w(\vec{x})\doteq\sum\limits_{i=0}^{w-1}x_i2^i$$

函数 $B2U_w$ 将一个长度为 $w$ 的 0，1 串映射到「非负整数」。例如：

$B2U_4([0001])=0\cdot2^3 + 0\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 = 0 + 0 + 0 + 1 = 1$

$B2U_4([1011])=1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0 = 8 + 0 + 2 + 1 = 11$


$w$ 位所能表示的最小值为 0，最大值为 $UMax_w\doteq\sum\limits_{i=0}^{w-1}2_i=2^w - 1$。因此，函数 $B2U_w$ 能够被定义为一个映射 $B2U_w:\lbrace 0, 1 \rbrace ^w \to\lbrace 0, \cdots, 2^w - 1 \rbrace$

无符号数编码的唯一性：函数 $B2U_w$ 是一个双射。
- 函数 $B2U_w$ 将每一个长度为 $w$ 的位向量都映射为 $0 \sim 2^w - 1$ 之间的一个唯一值。
- 反函数 $U2B_w$（即“无符号数到二进制”）将 $0 \sim 2^w - 1$ 之间的每一个整数都可以映射为一个唯一的长度为 $w$ 的位模式。 

---

表示负值，最常用的计算机表示方式是补码（two's-complement）形式。

补码编码的定义：对向量 $\vec{x}=[x_{w-1}, x_{w-2}, \cdots, x_0]$，定义函数：

$$B2T_w(\vec(x)\doteq - x_{w-1}2^{w-1} + \sum\limits_{i=0}^{w-2}x_i2^i$$

在这个定义中，将字的最高有效位 $x_{w-1}$ 解释为负权（negative weight），也称为符号位，它的“权重”为 $-2^{w-1}$，是「无符号」表示中权重的负数。符号位被置为 1 时，表示值为负，当设置为 0 时，值为非负。

例，从位向量到整数的映射：

$B2T_4([0001])=-0\cdot2^3 + 0\cdot2^2 + 0\cdot2^1 + 1\cdot2^0 = 0 + 0 + 0 + 1 = 1$

$B2T_4([1011])=-1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0 = -8 + 0 + 2 + 1 = -5$

$w$ 位补码所能表示的值的范围：

- 最小值是位向量 $[10...0]$，其整数值为 $TMin_w\doteq-2^{w-1}$。
- 最大值是位向量 $[01...1]$，其整数值为 $TMax_w\doteq\sum\limits_{i=0}^{w-2}2^i=2^{w-1} - 1$。

从值的范围可以看出，函数 $B2T_w$ 能够被定义为一个映射 $B2T_w：\lbrace 0，1 \rbrace ^w \to \lbrace TMin_w，\cdots，TMax_w \rbrace$。

补码编码的唯一性：函数 $B2T_w$ 是一个双射。
- 函数 $B2T_w$ 将一个长度为 $w$ 的位模式映射为 $TMin_w$ 到 $TMax_w$ 之间的一个唯一值 $x$。
- 对于每个数 $x$，满足 $TMin_w \le x \le TMax_w，$反函数 $T2B_w$（即补码到二进制）将 $x$ 映射为一个唯一的长度为 $w$ 的位模式。

---

几个重要数字的位模式和数值

{{<figure width="600" src="/images/important-number.jpg" title="重要的数字">}}

关于这些数字，值得注意的点：
- 补码的范围是不对称的：$|TMin|=|TMax| + 1$。之所以有这样的不对称性，是因为一半的位模式（符号位为 1 的数）表示负数，而另一半（符号位为 0 的数）表示非负数。0 是非负数，也就意味着能表示的正数比负数少一个。
- 最大的无符号数值刚好比补码的最大值的两倍大一点：$UMax_w=2TMax_w+1$。补码表示中所有表示负数的位模式在无符号表示中都变成了正数。就是说，同样的位模式用补码编码是负数，用无符号编码是正数。例如，对位模式 $[1011]$：$B2T_4([1011])=-1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0 = -5$，$B2U_4([1011])=1\cdot2^3 + 0\cdot2^2 + 1\cdot2^1 + 1\cdot2^0 = 11$
- -1 和 $UMax$ 有同样的位模式\-\-\-一个全 1 的串。数值 0 在两种表示方式（无符号和补码）中都是全 0 的串。

> C 语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。

---

有符号数和无符号数之间的转换，即 「补码」与「无符号」的相互转换。

对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是：**数值可能会改变（负数时数值会改变，正数不会改变），但是位模式不变**。


定义函数 $U2B_w$ 和 $T2B_w$，它们将数值映射为无符号数和补码形式的位表示。即：
- 给定 $0 \le x \le UMax_w$ 范围内的一个整数 $x$，函数 $U2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位无符号表示。
- 当 $x$ 满足 $TMin_w \le x \le TMax_w$，函数 $T2B_w(x)$ 会给出 $x$ 的唯一的 $w$ 位补码表示。

定义函数 $T2U_w$ 描述从补码到无符号的转换：$T2U_w(x) \doteq B2U_w(T2B_w(x))$。

定义函数 $U2T_w$ 描述从无符号数到补码的转换：$U2T_w(x) \doteq B2T_w(U2B_w(x))$。 

例：$T2U_{16}(-12345)=53191$，$U2T_{16}(53191)=-12345$。

从上面的例子看到，十六进制 0xCFC7 表示的 16 位位模式，既是 -12345 的补码表示，又是 53191 的无符号表示。**同样的位模式，不同的解释**。

给定位模式，函数 $T2U_w$（补码转为无符号数）的一个属性：

对满足 $TMin_w \le x \le TMax_w$ 的 $x$ 有：

$$
T2U_w(x)=\begin{cases}
x+2^w, & x < 0 \\\
x, & x \ge 0
\end{cases}
$$

函数 $U2T_w$（无符号数转换为补码）的一个属性：

对满足 $0 \le u \le UMax_w$ 的 $u$ 有：

$$
U2T_w(u)=\begin{cases}
u, & u \le TMax_w \\\
u-2^w, & u > TMax_w
\end{cases}
$$

可以看到无符号与补码之间相互转换，对于在范围 $0 \le x \le TMax_w$ 之内的值 $x$ 而言，得到 $T2U_w(x)=x，U2T_w(x)=x$。也就是说，在这个范围内的数字有相同的无符号和补码表示。对于这个范围以外的数值，转换需要加上或减去$2^w$。

> C 语言允许无符号数和有符号数之间的转换，虽然 C 标准没有规定应该如何进行这种转换，但大多数系统遵循的原则是：底层的位保持不变。