---
title: "深入理解计算机系统(csapp)笔记-存储器层次结构"
description: "这是深入理解计算机系统(Computer Systems A Programmer's Perspective 3rd)第六章的学习笔记."
date: 2022-05-17T15:22:10+08:10
draft: false
math: true
categories:
  - 读书笔记
tags:
  - cs
---

存储器系统（memory system）是一个具有不同容量、成本和访问时间的存储设备的层次结构。

## 局部性

编写良好的计算机程序常常具有良好的局部性（locality）。也就是，程序倾向于使用地址接近或等于它们最近使用过的地址的数据和指令。有良好局部性的程序比局部性差的程序运行得更快。

局部性通常有两种不同的形式：
- 时间局部性（temporal locality）。最近引用过一次的内存位置很可能在不远的将来再被多次引用。
- 空间局部性（spatial locality）。一个内存位置被引用了一次，那么程序很可能在不远的将来引用它相邻的内存位置。

现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。在硬件层，局部性原理允许计算机设计者通过引入小而快速的「高速缓存存储器」来保存最近被引用的指令和数据项，从而提供对主存的访问速度。

一个有良好局部性的函数：

```C
int sumvec(int a[n]) {
    int sum = 0;
    for (i = 0; i < n; i++) 
        sum += a[i];
    return sum;
}
```

数据引用上，每次迭代都会重复引用 sum，所以有很好的时间局部性，同时以顺序引用模式（也称为步长为 1 的引用模式，stride-1 reference pattern）访问数组 a 的元素，因此有良好的空间局部性。

取指令上，for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。又因为循环体会被执行多次，所以它也有很好的时间局部性。

一个空间局部性很差的函数：
```C
int sum_array_cols(int a[M][N]) {
    int i, j, sum = 0;

    for (j = 0; j < N; j++)
        for (i = 0; i < M; i++)
            sum += a[i][j];
    return sum;
}
```
C 数组在内存中是按照「行优先」顺序存放的，上面的函数是按照「列」顺序来扫描数组，而不是按照「行」顺序，结果就得到了步长为 N 的引用模式。步长的增大，会使得空间局部性下降。

只需要交换 i 和 j 的循环，使得嵌套循环按照「行优先顺序」读取数组元素

```
for (i = 0; i < M; i++)
    for (j = 0; j < N; j++)
        sum += a[i][j];
```

结果就得到一个很好的步长为 1 的引用模式，具有良好的空间局部性。

量化评价程序中局部性的一些简单原则：
- 重复引用相同变量的程序会有良好的时间局部性。
- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好。
    - 具有步长为 1 的引用模式的程序有很好的局部性。
    - 在内存中以大步长跳来跳去的程序空间局部性会很差。
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。

## 存储器层次结构

计算机硬件和软件系统有这样一些基本的和持久的特性：
- 速度较快的存储技术每个字节的成本总是更高，而且容量更小。
- 编写良好的程序往往具有良好的局部性。

这些属性完美的互相补充，使得可以用「存储器层次结构」的方式来组织内存和存储系统。

{{<figure width="600" src="/images/memory-hierarchy.jpg" caption="存储器层次结构">}}

存储器层次结构的基本思想是：**对于每个 k，位于 k 层的更快更小的存储设备作为位于 k+1 层更大更慢的存储设备的缓存**。也就是说，层次结构中的每一层都是缓存（caching）来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘读取的文件的缓存，主存作为本地磁盘上数据的缓存，依次类推，直到最小的缓存 \-\- CPU 寄存器组。

### 缓存的机制

使用高速缓存（cache）的过程称为缓存（caching），缓存的机制：

{{<figure width="600" src="/images/basic-principle-of-caching.jpg" caption="存储器层次结构中缓存的基本原理">}}

- 第 k+1 层的存储器被划分成连续的数据对象组块（chunk），称为块（block）。
    - 每个块都有一个唯一的地址或名字。
    - 块可以是固定大小的，也可以是可变大小的。
- 第 k 层的存储器被划分成较少的块的集合，每个块的大小与 k+1 层的块的大小一样。
    - 在任何时刻，第 k 层的缓存包含第 k+1 层块的一个字集的副本。
- 数据总是以块大小为「传送单元」（transfer unit），在第 k 层和第 k+1 层之间来回复制。

### 缓存命中和不命中

当程序需要第 k+1 层的某个数据对象 d 时，它首先在第 k 层的块中查找，如果 d 刚好缓存在第 k 层中，那么就是「缓存命中」（cache hit），程序直接从第 k 层中读取 d。

如果第 k 层没有缓存数据对象 d，那么就是「缓存不命中」（cache miss），这时，第 k 层就要从第 k+1 层中取出包含 d 的那个块。
- 如果第 k 层已经满了，就要覆盖现存的一个块。
- 覆盖现存的块的过程称为替换（replacing）或驱逐（evicting）这个块。被驱逐的这个块称为牺牲块（victim block）。
- 决定该替换哪个块是由缓存的「替换策略」（replacement plocy）来控制的。
    - 比如，随机替换策略会随机选一个牺牲块。LRU 替换策略会选择最近最少被使用的那个块。

缓存不命中的种类：
- 冷不命中（cold miss)。如果第 k 层的缓存是空的，那么对任何数据对象的访问都会不命中，此类不命中就称为冷不命中。
- 冲突不命中（conflict miss）。只要发生不命中，第 k 层就会执行放置策略（placement policy），放置策略可能会把下一次正好需要的数据块给替换（或驱逐）了，这样就会引起冲突不命中。
- 容量不命中（capacity miss）。当工作集的大小超过缓存的大小时，缓存就会经历容量不命中。

### 为什么存储器层次结构有效？

由于局部性，程序访问层级 k 的数据的频率往往高于访问层级 k+1 的数据的频率，因此，层级 k+1 的存储可以较慢，并且因此可以更大、更便宜。

> 存储器层次结构创建了一个大的存储池，其成本与底部附近的廉价存储器一样高，但它以顶部附近的快速存储器的速率向程序提供数据

## 高速缓存存储器（cache）

早期计算机系统的存储器层次结构只有三层：CPU 寄存器、DRAM 主存储器和磁盘存储。由于 CPU 和主存之间逐渐增大的差距，计算机系统设计者在 CPU 寄存器和主存之间插入了高速缓存存储器，最先是插入了一个小的 SRAM 高速缓存存储器，称为 L1 高速缓存（一级缓存），它的访问速度几乎和寄存器一样快（大约 4 个时钟周期）。随着 CPU 和主存之间的性能差距不断增大，系统设计者又在 L1 高速缓存和主存之间插入了一个更大的高速缓存，称为 L2 高速缓存（访问速度大约 10 个时钟周期）。像 Intel Core i7 这样的现代系统，在 L2 和 主存之间还插入了一个更大的 L3 高速缓存（访问速度大约 50 个时钟周期）。

{{<figure width="600" src="/images/intel-core-i7-cache-hierarchy.jpg" caption="Intel Core i7 存储器层次结构">}}

### 通用高速缓存存储器的组织结构

前面有讲过，存储器之间的数据总是以「块大小」（block size）作为传送单元的：
- 块的大小以字节为单位，始终是 2 的幂。比如，64 Byte。$64B=2^6$=$log_2(64)$。
- 块由相邻字节组成（地址相差 1)。

每个存储器地址有 $m$ 位，这就有了 $M=2^m$ 个不同的地址。一个通用的高速缓存被组织成一个有 $S=2^s$ 个「高速缓存组（cache set）」的数组。每个组包含 $E$ 个「高速缓存行（cache line）」。每个高速缓存行包含一个 $B=2^b$ 字节的数据「块（block）」、一个「有效位」，以及 $t=m-(b+s)$ 个「标记位」。

高速缓存的结构一般用元组 $(S,E,B,m)$ 来描述。高速缓存的大小（或容量）$C$ 指的是所有数据块（block）的大小之和。标记位和有效位不包括在内。因此，$C=S \times E \times B$。即，容量=组 x 行 x 数据块大小。

高速缓存的结构将 $m$ 个「地址位」划分成了 $t$ 个「标记位」，$s$ 个「组索引位」和 $b$ 个「块偏移位」。
