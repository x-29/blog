---
title: "深入理解计算机系统(csapp)笔记-异常控制流"
description: "这是深入理解计算机系统(Computer Systems A Programmer's Perspective 3rd)第六章的学习笔记."
date: 2022-05-18T19:52:20+08:10
draft: false
math: false
categories:
  - 读书笔记
tags:
  - cs
---

异常控制流的基本机制是用于：
- 在进程和操作系统之间转移控制
- 在操作系统中处理 I/O 和虚拟内存
- 实现多进程应用程序，如 shell 和 web 服务器
- 实现并发

## 异常

异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常就是控制流中的突变，它将控制转移到操作系统内核，以响应某些事件（例如，处理器状态的变化）。
- 内核是操作系统常驻内存的部分
- 异常示例：除 0，页故障，I/O 请求完成，Ctrl-C。

{{<figure width="600" src="/images/anatomy-of-an-exception.jpg">}}

当处理器（CPU）检测到有事件发生时，它怎么知道要跳转到操作系统中的哪个地方呢？

答案是异常跳转表，也称为中断向量表。

{{<figure width="400" src="/images/exception-table.jpg" caption="异常跳转表，其中条目 k 包含异常 k 的处理程序代码的地址">}}

- 系统中的每种类型的事件都有一个唯一的异常号 k。
    - 一些异常号是由处理器的设计者分配的。比如，除 0、缺页、内存访问违例、断点以及算术运算溢出。
    - 其他是由操作系统内核的设计者分配的。比如，系统调用和来自外部 I/O 设备的信号。
- 在系统启动时，操作系统分配和初始化异常跳转表，使得表目 k 包含异常 k 的处理程序的地址。
    - k 等同于异常表的索引，也称为中断向量
- 在运行时（当系统在执行某个程序时），处理器检测到异常编号为 k 的事件发生时，就触发异常，执行间接过程调用，跳转到 k 的处理程序。

> 异常跳转表的起始地址存放在一个叫做「异常表基址寄存器」的特殊 CPU 寄存器里。

一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在异常处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，将适当的状态弹回到处理器的控制和数据寄存器中，可选地返回到被中断的程序，如果异常中断的是一个用户程序，就将状态恢复为「用户模式」，然后将控制返回给被中断的程序。

---

异常可分为四类：
- 中断（interrupt）。
- 陷阱（trap）
- 故障（fault）
- 终止（abort）

其中，中断是异步发生的，是来自处理器外部的 I/O设备的信号引发的。其他 3 类异常时同步发生的，是执行当前指令而引发的。这类指令叫做故障指令（faulting instruction）。

### 中断（interrupt）

硬件中断不是由任何一条专门指令造成的，而是通过设置处理器的中断引脚（连接到 CPU），并将异常号放到系统总线上，来触发中断。硬件中断的异常处理程序称为中断处理程序（interrupt handler），当处理程序返回时，它将控制返回给下一条指令，也就是如果没有发生中断，在控制流中会在当前指令之后的那条指令。

中断示例：
- I/O 中断
    - 按下键盘上的 Ctrl-C 键
    - 单击鼠标按钮或是轻按触摸屏
    - 来自网络的数据包到达
    - 来自磁盘的数据到达
- 定时器中断
    - 每隔几毫秒，外部定时器芯片就会触发一次中断
    - 操作系统内核从用户程序收回控制权

### 陷阱（trap)

陷阱是「有意的」异常，以将控制权移交给操作系统执行某些功能。比如，系统调用、断点陷阱、特殊指令。陷阱处理程序将控制返回到下一条指令。

陷阱最重要的用途时在用户程序和内核之间提供一个像过程一样的接口，叫做「系统调用」。用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork）、加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的「syscall n」指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，由处理程序解析参数，并调用适当的内核程序。

> 普通的函数运行在「用户模式」中，用户模式限制了函数可以执行的指令类型，而且它们只能访问与调用函数相同的栈。系统调用运行在「内核模式」，内核模式运行系统调用执行特权指令，并访问定义在内核中的栈。

下面是一个调用系统调用 open(filename, options) 的示例：

```
00000000000e5d70 <__open>:
...
e5d79:   b8 02 00 00 00      mov  $0x2, %eax                  # open is syscall 2
e5d7e:   0f 05               syscall                          # return value in %rax
e5d80:   48 3d 01 f0 ff ff   cmp  $0xfffffffffffff001, %rax 
...
e5dfa:   c3                  retq
```

{{<figure width="400" src="/images/trap-example.jpg">}}

每个系统调用都有一个唯一的 ID 号，系统调用 open 的 ID 号是 2。 

### 故障（fault）

故障是「无意的」，由错误情况引起，它可能能够被故障处理程序修正。比如，缺页、段保护故障、除 0。如果处理程序能够修正错误，它就将控制返回到引发故障的指令，重写执行。否则，返回到内核中的 abort 例程，abort 例成会终止引发故障的应用程序。

例如，缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。

```C
int a[1000];
int main () {
    a[500] = 13;
}

```
```
80483b7:	c7 05 10 9d 04 08 0d 	movl   $0xd,0x8049d10
```

{{<figure width="400" src="/images/fault-example.jpg">}}

缺页处理程序必须从磁盘加载页面到物理内存，然后将控制返回给引起故障的指令（movl），再次执行时，就会无故障地成功完成。

### 终止（abort）

终止也是「无意的」异常，但它是不可恢复的。通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏是发生的奇偶错误。终止处理程序从不将控制返回给应用程序，而是返回给一个 abort 例程来终止应用程序。

## 进程

异常控制流是操作系统用来使多个进程在同一系统上运行的机制。**进程是一个正在运行的程序的实例**。它是计算机科学中最深刻、最成功的概念之一。进程与程序（program）或处理器（processor）不同。系统中的每个程序都运行在某个进程的「上下文（context）」中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

{{<figure width="600" src="/images/process-illusion.jpg">}}

进程为每个应用程序提供了两个关键的抽象：
- 逻辑控制流
    - 它提供一个假象，每个程序好像都独占地使用处理器。
    - 由称为「上下文切换（context switching）」的内核机制提供。
- 私有地址空间
    - 它提供一个假象，每个程序好像都独占地使用主内存。
    - 由称为「虚拟内存」的内核机制提供。

### 逻辑控制流

每个进程都是一个逻辑控制流。计算机系统中逻辑流有多种不同的形式。比如，异常处理程序、进程、信号处理程序、线程和 Java 进程。

如果两个进程的指令执行（逻辑流）在时间上重叠，那么这两个进程是并发地运行，否则就是顺序地运行。更准确地说，逻辑流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。

下面是一个在单核 CPU 上运行三个进程的例子。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。

{{<figure width="600" src="/images/logical-control-flows.jpg" caption="逻辑控制流。每个竖直的条表示一个进程的逻辑控制流的一部分">}}

三个进程轮流使用处理器，每个进程执行它的逻辑流的一部分，然后被抢占（preempted）（暂时挂起），轮到其他进程。进程 A 和 B，A 和 C 是并发地运行。进程 B 和 C 是顺序地运行。

多个控制流并发地执行被称为并发（concurrency）。一个进程和其他进程轮流运行，称之为多任务（multitasking）。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice）。因此，多任务页叫做时间分片（time slicing）。例如，上图中的进程 A 的控制流由两个时间片组成。

并发进程的控制流在时间上是物理分离的，但是，用户可能将并发进程看作为在同一个时间并行（parallel）地执行。

### 私有地址空间

在一台 n 位地址的机器上，「地址空间」是 2^n 个可能地址的集合。进程为每个程序提供它自己的私有地址空间。和这个空间中某个地址相关联的那个内存字节（一个地址对应一个字节）是不能被其他进程读或者写的。

进程的私有地址空间的组织结构是相同的，例如，x86-64 Linux 进程的地址空间的组织结构：

{{<figure width="600" src="/images/process-address-space.jpg" caption="进程地址空间">}}

地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。内核不是一个单独的进程，而是作为用户进程的一部分运行。

### 上下文切换

上下文切换（context switch）是由内核代码执行的，它将控制流从一个进程转移到另一个进程。内核为每个进程维持一个「上下文（context）」。上下文就是内核重新启动一个被抢占的进程所需的状态。在进程执行的某个时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策叫调度（scheduling），由内核中的「调度器（scheduler）」的代码处理。在内核调度一个新的进程，抢占当前进程时，它使用上下文切换机制来将控制转移到新的进程。

{{<figure width="600" src="/images/context-switch.jpg" caption="进程上下文切换">}}

上下文切换，1）首先，保存当前进程的上下文，2）然后，恢复先前被抢占的进程被保存的上下文，3）最后将控制传递给新恢复的进程。当内核代表用户执行系统调用时，可能会发生上下文切换。中断也可能引发上下文切换。

## 创建新的进程

C 程序可以通过 fork 函数创建进程。

```
pid_t fork(void)
```
fork 函数创建一个与当前进程几乎相同的新子进程，子进程包括了父进程的所有状态（内存，寄存器等）。

fork 函数调用一次，会返回两次：一次是在调用进程（父进程）中，返回值为子进程的 PID，一次是在新创建的子进程中，返回值为 0。通过判断返回值可以分辨程序是在父进程还是在子进程中执行。

一个使用 fork 传教子进程的示例：
```C
void fork1() {
    int x = 1;
    pid_t pid = fork();
    if (pid == 0)
	    printf("Child has x = %d\n", ++x);
    else
	    printf("Parent has x = %d\n", --x);
    printf("Bye from process %d with x = %d\n", getpid(), x);
}
```

进程图如下：

{{<figure width="400" src="/images/process-graph.jpg">}}

### 加载并运行程序

execve 函数在当前进程的上下文中加载并运行一个新程序。
```
int execve(const char *filename, const char *argv[], const char *envp[])
```

