---
title: "深入理解计算机系统(csapp)笔记-程序的机器级表示"
description: "这是深入理解计算机系统(Computer Systems A Programmer's Perspective 3rd)第三章的学习笔记."
date: 2022-05-16T10:12:20+08:10
draft: false
math: true
categories:
  - 读书笔记
tags:
  - cs
---

计算机执行「机器代码」，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。

汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。

## 程序编码

假设一个 C 程序，有两个文件 p1.c 和 p2.c。用下面的 Unix 命令编译这些代码：
```shell
linux> gcc -Og -o p p1.c p2.c
```
命令 gcc 指的是 GCC C 编译器，这是 Linux 上默认的编译器。

gcc 命令实际上会调用一整套的程序，将源代码转换成可执行代码。
- 首先，调用「C 预处理器」扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。
- 其次，调用「编译器」产生两个源文件的汇编代码，名字分别为 `p1.s` 和 `p2.s`。
- 接下来，调用「汇编器」将汇编代码转换成二进制「目标代码」文件 `p1.o` 和 `p2.o`。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
- 最后，调用「链接器」将两个目标代码文件与实现库函数的代码合并，并产生最终的「可执行」代码文件 p。可执行代码是机器代码的第二种形式。

---

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要：
1. 由「指令集体系结构或指令集架构（Instruction Set Architecture，ISA）」来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数值。

C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大、按字节寻址的数组。
- C 语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。
- 对标量数据类型，汇编代码也不区分有符号或无符号，不区分各种类型的指针，甚至不区分指针和整数。

在 gcc 命令上使用 "-S" 选项，可以产生一个汇编文件，例如：
```shell
linux> gcc -Og -S mstore.c
```
执行这条命令，将会使 GCC 运行编译器，产生一个汇编文件 `mstore.s`，但不做进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。

使用 “-c“ 选项，GCC 会执行编译并汇编代码，例如：
```shell
linux> gcc -Og -c mstore.c
```
这会产生目标代码文件 mstore.o，它是二进制格式的，所以我们无法直接查看。

要想查看机器代码文件的内容，可以使用「反汇编器」程序，例如，在 Linux 系统中，带 '-d' 选项的 objdump 命令。
```shell
linux> objdump -d mstore.o
```
查看机器代码文件的内容，我们会发现「**机器执行的程序只是一个字节序列，它是对一系列指令的编码**」。例如：
```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```
这些字节分成若干组，每组有 1 ～ 5 个字节。**每组都是一条指令**。例如 `53` 是 `push %rbx` 指令，`48 89 d3` 是指令 `mov %rdx, %rbx`。机器对产生这些指令的源代码几乎一无所知。

---

汇编代码格式有两种：ATT 格式和 Intel 格式。
- GCC、objdump 用得是 ATT 格式的汇编代码。
- Microsoft 的工具，以及 Intel 的文档，都是使用 Intel 格式的汇编代码。

Intel 和 ATT 格式的一些主要不同点：

- Intel 代码省略了指示大小的后缀。如指令 push 和 mov，而不是 pushq 和 movq。
- Intel 代码省略了寄存器名字前面的 '%' 符号，用的是 rbx，而不是 %rbx。
- Intel 代码用不同的方式来描述内存中的位置，例如 'QWORD PTR [rbx]'，而不是 '(%rbx)'。
- 在有多个操作数的指令中，列出的操作数的顺序相反。

## 数据格式

由于是从 16 位体系结构扩展成 32 位的，Intel 用术语「字（word）」表示 16 位数据类型。因此，称 32 位数为「双字（double words）」，64 位数为「四字（quad words）」。

C 语言基本数据类型对应的 x86-64 表示：

{{<figure width="600" src="/images/c-data-types-x86.jpg" caption="C 语言数据类型在 x86-64 中的大小">}}

如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。

例如，数据传输指令的 4 个变种：
- movb，传送字节
- movw，传送字
- movl，传送双字
- movq，传送四字。

## 访问信息

一个 x86-64 的 CPU 包含一组 16 个存储「64 位」值的「通用目的寄存器」。这些寄存器用来「存储整数数据和指针」。

> 每个 CPU core 都有各自的寄存器。

如图：

{{<figure src="/images/integer-registers.jpg" caption="整数寄存器">}}

所有 16 个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字访问，即：
- 字节级操作可以访问最低的字节（8位）。
- 16 位操作可以访问最低的 2 个字节（16位）。
- 32 位操作可以访问最低的 4 个字节（32位）。
- 64 位操作可以访问整个寄存器。

程序计数器是特殊的寄存器，通常称为 PC，在 x86-64 中用 %rip 表示，它给出将要执行的下一条指令在内存中的地址。

> 在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是「栈指针 %rsp」，它用来指明运行时栈的结束位置。

有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。

### 寻址方式

大多数指令有一个或多个操作数（operand）。指令的操作数分为三种类型：
- 立即数（immediate），用来表示常数值。如 `$-577`，`$0x1F`。
- 寄存器（register），表示某个寄存器的内容。
- 内存引用 ，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置，也就是读取内存位置所存放的值。

内存引用有多种不同的形式，最常用的形式为：$Imm(r_b，r_i，s)$。这样的引用有四个组成部分：
- 一个立即数偏移量 $Imm$。
- 一个基址寄存器 $r_b$。
- 一个变址寄存器 $r_i$。
- 一个比例因子 $s$。$s$ 必须是 1、2、4 或者 8。

它所表示的地址可以这样计算出来：

$$Imm+R[r_b]+R[r_i] \cdot s$$

符号说明：符号 $r_a$ 表示任意寄存器 $a$，$R[r_a]$ 表示它的值。这是将寄存器集合看成一个数组 $R$，用寄存器标识作为索引。

其他形式都是这种形式的特殊情况，只是省略了某些部分，相当于这些部分是 0。
|名称|格式|操作数类型|说明|
|--|--|--|--|
|直接（绝对）寻址（Direct/Absolute Addressing Mode））|$Imm$ |Memory| 只使用 $Imm$ 寻址，例如 movl 0x20, %eax。把地址 0x20 处的 32 位数传送到 eax 寄存器。注意与立即数寻址的区别，这里是直接的内存地址。|
| 间接寻址（Indirect Addressing Mode）|($r_b$) | Memory | 只使用 $r_b$ 寻址。例如 movl (%eax), %ebx。把 eax 寄存器的值看做内存地址，把内存中这个地址处的 32 位数传送到 ebx 寄存器。**注意与 movl %eax, %ebx 区分开来**。|
|(基址+偏移量)寻址（Base Pointer Addressing Mode）| $Imm(r_b)$| Memory| 只使用 $Imm$ 和 $r_b$ 寻址，例如 movl 4(%eax), %ebx。用于访问结构体成员比较方便，例如一个结构体的基地址保存在 eax 寄存器中，其中一个成员在结构体内的偏移量是 4 字节，要把这个成员读上来就可以用这条指令|
| 变址寻址（Indexed Addressing Mode） | $(r_b,r_i)、Imm(r_b,r_i)$、$(,r_i,s)、Imm(,r_i,s)$、$(r_b,r_i,s)$、$Imm(r_b，r_i,s)$| Memory|例如 movl items(,%edi,4), %eax 就属于这种寻址方式，用于访问数组元素比较方便 |
|立即数寻址（Immediate Mode） | $Imm$ | 立即数 | 就是指令中有一个操作数是立即数，例如 `movl $12, %eax`中的 $12，这其实跟寻址没什么关系，但也算作一种寻址方式。|
|寄存器寻址（Register Addressing Mode） | $r_a$ | Register | 就是指令中有一个操作数是寄存器，例如movl $12, %eax 中的 %eax，这跟内存寻址没什么关系，但也算作一种寻址方式。|

看几个例子，加深理解，假设下面的值存放在指明的内存地址和寄存器中：

|内存地址|值|寄存器|值|
|---|---|---|---|
|0x100|0xFF|%rax|0x100|
|0x104|0xAB|%rcx|0x1|
|0x108|0x13|%rdx|0x3|
|0x10c|0x11|

给出所示操作数的值：
|操作数|值|注释|
|---|---|---|
|%rax|0x100|寄存器寻址|
|0x104|0xAB|直接寻址|
|$0x108|0x108|立即数寻址|
|(%rax)|0xFF|间接寻址，内存地址 0x100|
|4(%rax)|0xAB|变址寻址，内存地址 0x104|
|9(%rax,%rdx)|0x11|变址寻址，内存地址 0x10c|
|260(%rcx,%rdx)|0x13|变址寻址，内存地址 0x108。十进制 264 用十六进制表示就是 0x108|
|0xFC(,%rcx, 4)|0xFF|变址寻址，内存地址 0x100|
|(%rax,%rdx, 4)|0x11|变址寻址，内存地址 0x10c|

### 数据传送指令

数据传送指令（Move）是将数据从一个位置复制到另一个位置的指令，它有两个操作数：源操作数和目的操作数。
- 源操作数指定的值是一个立即数，存储在寄存器（register）中或者内存（memory）中。
- 目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。
- X86-64 限制传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令。第一条指令将源值加载到寄存器中，第二条将寄存器的值写入目的位置。

寄存器部分的大小必须与指令最后一个字符（'b', 'w', 'l' 或 'q'）指定的大小匹配，如：

```
movl $0x4050, %eax         Immediate -- Register, 4 bytes
movb $-17, (%rsp)          Immediate -- Memory,   1 bytes
movb (%rdi, %rcx), %al     Memory -- Register,    1 bytes
movw %bp, %sp              Register -- Register,  2 bytes
movq %rax, -12(%rbp)       Register -- Memory,    8 bytes
```

可以看到上面的 movl 指令是传送 4 个字节的数据到寄存器中，所以寄存器用 32 位的 `%eax`。同样的，movb 指令是传送 1 个字节的数据，寄存器用 8 位的 `%al`。后面的 `%bp`、`%sp`、`%rax` 也都是与指令最后一个字符指定的大小相匹配的。

当指令以寄存器为目的操作数时，对于生成小于 8 字节的指令，寄存器中剩下的字节会怎样处理呢？对此有两条规则：
- 生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。
- 生成 4 字节的指令会把高位 4 个字节置为 0。
  - movl 指令以寄存器作为目的操作数时，它会将寄存器的高 4 字节置为 0。

例如：
```
movabsq $0x0011223344556677, %rax      %rax = 0011223344556677
movb    $-1, %al                       %rax = 00112233445566FF
movw    $-1, %ax                       %rax = 001122334455FFFF
movl    $-1, %eax                      %rax = 00000000FFFFFFFF
movq    $-1, %rax                      %rax = FFFFFFFFFFFFFFFF
```

第一条 `movabsq` 指令传送绝对的四字，能够以任意 64 位立即数作为源操作数，并且只以寄存器作为目的操作数。在这里它把寄存器 %rax 初始化为位模式 0011223344556677。

在将较小的源值传送到较大的目的时，需要先对源值做扩展：
- `MOVZ S, R` 类的指令是做零扩展，用 0 填充。
- `MOVS S, R` 类的指令是做符号扩展，用符号为来填充。

例如，%dl = AA，执行 movzbl %dl, %eax 后 %eax = 000000AA。movzbl 指令会先对 %dl 的值做零扩展到 32 位（命令中的字符 l 指明了目的的大小，b 表示源值的大小），也就是前 24 位填充 0，再将值传送到 %eax 中。执行 movsbl %dl, %eax 后 %eax=FFFFFFAA。

> 数据传送指令中有一条 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 为源操作数，%rax 为符号扩展结果的目的操作数。它的效果与指令 movslq %eax, %rax 完全一致。

下面结合 C 程序来看一个数据传送的示例：

C 代码：
```C
long exchange(long *p, long y) {
  long x = *xp;
  *xp = y;
  return x;
}
```

汇编代码：

```
    long exchange(long *xp, long y)
    xp in %rdi, y in %rsi

1   exchange:
2     movq  (%rdi), %rax      Get x at xp. Set as return value.
3     movq  %rsi, (%rdi)      Store y at xp.
4     ret                     Return
```

我们看到函数 exchange 由三条指令实现：两条数据传送（movq），加上一条返回函数被调用点的指令（ret）。

当过程开始执行时，过程参数 xp 和 y 分别存储在寄存器 %rdi 和 %rsi 中。然后，指令 2 从内存中读出 x，把它存放到寄存器 %rax 中，直接实现了 C 程序中的 x=*xp 操作。指令 3 将 y 写入到寄存器 %rdi 中的 xp 指向的内存位置，直接实现了操作 *xp=y。

从这个段汇编代码中我们可以看到这么两点：
- C 语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用（$Imm(r_b,r_i,s)$)中使用这个寄存器。
- 局部变量（如：x）通常保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。

有关 C 指针的一些示例：

```
char *p;
p = &a;        // p 存储的是地址。C 操作符 & 称为“取址” 操作符，它创建一个指针。

char b = *p;   // 读取 p 所指向位置中的值，并将它存放到变量 b 中。C 操作符 * 执行指针的间接引用。
*p = c;        // 将 c 的值写到 p 所指向的位置。这也是指针间接引用的一种形式。
```

### 压入和弹出栈数据

「栈」是一个种数据结构，可以添加或者删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作弹出（删除）数据。pop 操作的值永远是最近被压入而且仍然在栈中的值。

在 x86-64 中，程序栈存放在内存中某个区域。`pushq` 指令把数据压入到栈中，`popq` 指令从栈中弹出数据。这两条指令都只有一个操作数。

{{<figure width="600" src="/images/push-pop-instructions.jpg" caption="入栈和出栈指令。操作数 S：表示压入栈的数据源，操作数 D：表示弹出的数据目的">}}

将一个四字的值压入栈中，首先要将栈指针减 8，然后将值写到新的栈地址。因此，指令 pushq %rbp 的行为等价于下面两条指令：

```
subq $8, %rsp        Decrement stack Pointer
movq %rbp, (%rsp)    Store %rbp on stack
```

弹出一个四字的操作，首先是从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq %rax 等价于下面两条指令：
```
movq (%rsp), %rax      Read %rax from stack
addq $8, %rsp          Increment stack pointer
```
栈总是从一端压入或弹出数据。这一端称之为「栈顶」。

在 x86-64 中，「**栈向低地址方向增长，栈顶元素的地址是所有栈元素地址中最低的**」。栈指针 %rsp 保存着栈顶元素的地址。所以压栈是减小栈指针（寄存器 %rsp）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。

看一个栈操作的例子。最开始是 %rsp 为 0x108，%rax 为 0x123。

{{<figure width="600" src="/images/stack-operation.jpg" caption="栈操作">}}

执行指令 `pushq %rax`，首先将 %rsp 减去 8，得到 0x100，然后把值 0x123 存放到内存地址 0x100 处。

执行完 pushq 指令后，接着就执行 `popq %rdx` 指令，这时先从内存中读出值 0x123，再写到寄存器 %rdx 中，最后，寄存器 %rsp 的值增加 8，回到了 0x108。

我们可以看到，**%rsp 指向的地址总是栈顶**。

栈和程序代码以及其他形式的程序数据都是放在同一个内存中的，**程序可以用标准的内存寻址方法访问栈内的任意位置**。例如，假设栈顶元素是四字，指令 movq 8(%rsp), %rdx 会将第二个四字从栈中复制到寄存器 %rdx。

## 算术和逻辑操作

在 x86-64 中的算术和逻辑操作，可以分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，一元操作只有一个操作数。

{{<figure src="/images/integer-arithmetic-operations.jpg" width="600" caption="整数算术操作">}}

加载有效地址（Load effective address) 指令 `leaq S, D`:
- S 是地址表达式。
- D 是一个寄存器。

leaq 指令是将 D 设置为 S 表达式计算出来的地址。例如，leaq (%rdx, %rcx, 4), %rax，它会将表达式 `R[%rdx] + R[%rcx] * 4` 计算出来的地址，写入到寄存器 %rax 中。

需要特别注意：leaq 指令的第一个操作数 S，只做数学计算，不做内存引用。

用一个例子来对 leaq 和 movq 指令做个比较，能更好的理解它。

{{<figure width="600" src="/images/leaq-vs-movq.jpg" caption="leaq vs movq">}}

这种只做数学运算不做内存引用的特点，使得 leaq 指令在一些简单的算术表达式中很有用处。

例如，有这么一个 C 函数：

```C
long arith (long x, long y, long z) {
  long t1 = x + y;
  long t2 = z + t1;
  long t3 = x + 4;
  long t4 = y * 48;
  long t5 = t3 + t4;
  long rval = t2 * t5;
  return rval;
}
```

编译时，该函数的算术运算会以 leaq 来实现。汇编代码如下：

```
  long arith (long x, long y, long z)
  x in %rdi, y in %rsi, z in %rdx

arith:
  leaq  (%rdi, %rsi), %rax            #t1 = x + y
  addq  %rdx, %rax                    #t2 = z + t1;
  leaq  (%rsi, %rsi, 2), %rdx         #y+2y=3y
  salq  $4, %rdx                      #t4 = 3y * 16 = y * 48
  leaq  4(%rdi, %rdx), %rcx           #t5 = 4 + x + t4 = t3 + t4
  imulq %rcx, %rax                    #return t2 * t5
  ret
```

---

`subq %rax, %rdx ` 指令，可以解读成 "从 %rdx 中减去 %rax"。subq 指令有两个操作数：
- 第一个操作数是源操作数，可以是立即数、寄存器或是内存位置。
- 第二个操作数是目的操作数，它既是源又是目的，可以是寄存器或是内存位置。当为内存位置时，处理器必须**从内存读出值**，执行操作，再把结果写回内存。

例如，给出内存地址和寄存器的情况的如下：

```
Memory Address  |  Value            Register |  Value
---------------------------       -----------------------
  0x100         |   0xFF              %rax   |  0x100
  0x108         |   0xAB              %rcx   |  0x1
  0x110         |   0x13              %rdx   |  0x3
```
执行指令
```
Instruction          |  Destination  |  Value
-----------------------------------------------
  addq %rcx, (%rax)  |   0x100       |  0x100
  subq %rdx, 8(%rax) |   0x108       |  0xA8
```

目的操作数 (%rdx)、8(%rax) 都为内存地址，要先从内存中读出值，它们的值分别为 0xFF、0xAB，执行操作后，再把结果写回到内存。最后，内存地址 [0x100] 的值为 0x100，内存地址 [0x108] 的值为 0xA8。

---

`sal、shl` 为左移位指令，两者都是将右边填上 0。

`sar` 为算术右移，填符号为。

`shr` 为逻辑右移，填上 0。

移位操作的源操作数为移位量，可以是一个立即数，或者放在单字节寄存器 %cl 中。目的操作数为要移位的数，可以是一个寄存器或是一个内存位置。

例如：

```
sal $4, %rax
sar %cl, %rax
```

---

`xorq %rdx, %rdx`，这条指令会将寄存器 %rdx 设置为 0。对于任意 x，x^x = 0。

## 控制

C 语言中的条件语句、循环语言和分支语言，要求有条件的执行，根据测试的结果决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。

除了整数寄存器，CPU 还维护着一组「**单个位**（single bit）」的「条件码」（condition code）寄存器，它们描述了最近算术或逻辑操作的情况。可以检查这些寄存器来执行条件分支指令。

最常用的条件码有：
- CF：进位标志。最近的操作使最高位产生了进位。可以用来检查无符号操作是否溢出。
- ZF：零标志。最近的操作得出的结果为 0。
- SF：符号标志。最近的操作得到的结果为负数。
- OF：溢出标志。最近的操作导致一个补码溢出。

除了 leaq 指令不改变任何条件码，前面（图：*整数算术操作*）列出的算术和逻辑操作指令都会设置条件码。
- 对于逻辑操作，例如 XOR，进位标志（CF）和溢出标志（OF）会设置为 0.
- 对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。
- INC 和 DEC 指令会设置溢出和零标志，但不会改变进位标志。

另外，CMP 和 TEST 这两类指令也会设置条件码，但它们不会改变任何其他的寄存器，就是说不会更新目的寄存器。比如，`cmp S1, S2 `指令根据两个操作数之差（S2-S1）来设置条件码，它不会改变 S2 的值。

`test S1, S2` 指令的结果是基于 S1&S2。典型的用法是，两个操作数是一样，比如，testq %rax, %rax 指令用来检查 %rax 是负数、零，还是正数。或者其中一个操作数是一个掩码，用来指示哪些为应该被测试。

---

条件码通常不会直接读取，常用的使用方法有三种：
- 可以根据条件码的某种组合将一个字节设置为 0 或者 1。
- 可以条件跳转到程序的某个其他的部分。
- 可以有条件地传送数据。

SET 指令就是根据条件码的某种组合，将一个字节设置为 0 或者 1。

{{<figure width="600" src="/images/setx.jpg" caption="SET 指令">}}

- SET 指令的目的操作数是低位单字节寄存器（如 al、dl）之一，或者是一个字节的内存位置。
- SET 指令不会修改寄存器的剩余字节。
  - 通常用 `movzbl` 指令来将高 32 位设置为 0。
  - 我们知道，在 x86-64 中，任何为寄存器生成 32 位（4 字节）值的指令，也会将寄存器的高位部分（最高 4 个字节）设置为 0。比如，movl、movzbl、movsbl。


例如，有 C 代码：

```
int gt(long x, long y) {
  return x > y;
}
```

它的汇编指令如下：

```
  int get(long x, long y)
  x in %rdi, x int %rsi

gt:
  cmpq    %rsi, %rdi  # compare x:y
  setg    %al         # al = x > y
  movzbl  %al, %eax   # Zero rest of %rax
  ret
```

先是执行比较指令，根据计算（y - x）设置条件码。然后，setg 指令根据条件码的组合（~(SF^0F)&~ZF），将 %al 设置为 0 或 1。最后，movzbl 指令将高位填充为 0 传送到 %rax 作为结果返回。

---




